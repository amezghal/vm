#### Lexer
the lexer will parse the input and convert it into a stream of tokens.

examples of tokens:

keywords (if, else, for, func)

operators: +, -, /, *, %, ++, --, ...

grammar separators: _{_, _}_, _\[_, _\]_, _(_, _)_ ...

types: *string*, *number*,

#### Parser
the parser goal is to read the *lexer* tokens and:
1. validate the grammar is correct and report errors if any
2. build the AST (Abstract Syntax tree)

the main challenge is parsing expressions, ex: (5*4(cos(3-4+2*3)))

Since the target VM is a Stack VM (all local variables should be on the stack), there are no registers,
then while parsing/building an expression AST node,
the parser will convert all expressions from their _infix_ notation, to the postfix notation.

Ex: 5 + 3 * 4 => 3 4 * 5 +

then the parser will simply return the AST of the entire program.

#### Compiler

The compiler goal is to walk the AST and generate valid instructions for the VM, and provide extra meta-data for the VM to run properly.

but also, it has to do some extra work mainly:
1. dealing with local/global variables
2. function calls conventions
3. Statically compute the values of SP, SBP
4. compute addresses for VM branching ahead of time [if, else, loops ...]

#### VM

simply execute the generated bytecode.
But the design of the VM will impact heavily the compiler.

any changes to the VM requires changes to the Compiler


